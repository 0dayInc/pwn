#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pwn'
require 'json'
require 'nokogiri'
require 'optparse'

# Set the path to your project directory
opts = {}
OptionParser.new do |options|
  options.banner = "USAGE:
    #{File.basename($PROGRAM_NAME)} [opts]
  "

  options.on('-rPATH', '--rdoc-root-dir=PATH', '<Optional - RDoc root directory (Default: "/opt/pwn/rdoc/PWN")>') do |r|
    opts[:rdoc_root] = r
  end

  options.on('-jPATH', '--jsonl-results=PATH', '<Optional - Path to save JSONL file (Default: "/tmp/RDoc_Parent_Basename-TIMESTAMP.jsonl">') do |j|
    opts[:jsonl_results] = j
  end
end.parse!

begin
  rdoc_root = opts[:rdoc_root] ||= '/opt/pwn/rdoc/PWN'
  raise 'ERROR: RDoc root directory not found.' unless Dir.exist?(rdoc_root)

  # Set the path to save the JSONL file
  timestamp = Time.now.strftime('%Y-%m-%d-%H.%M.%S')
  rdoc_root_basename = File.basename(rdoc_root)
  jsonl_results = opts[:jsonl_results] ||= "/tmp/#{rdoc_root_basename}-#{timestamp}.jsonl"

  # List of HTML files generated by rdoc (adjust based on your project's structure)
  # Omit the first element, which is the Object.html file
  rdoc_html_files = Dir.glob("#{rdoc_root}/**/*.html")
  rdoc_html_files.push("#{rdoc_root}.html")

  html_to_jsonl = []
  rdoc_html_files.sort.each do |rdoc_html_file|
    # Parse the HTML content
    html_markup = Nokogiri::HTML.parse(File.read(rdoc_html_file))

    # Consume Public Constants, Public Class Methods, Public Instance Methods, and Public Attributes
    # from the html_markup and convert them to JSONL format, pushing into the html_to_jsonl array
    # JSONL format should be the following:
    # { "prompt": "Using Module_Namespace.method", "completion": "Module_Namespace.method.description" }
    # puts "Parsing: #{rdoc_html_file}"
    # gets

    module_name = html_markup.xpath('//main/h1').text.split[1]
    # puts "Module: #{module_name.inspect}"
    # gets

    html_markup.xpath('//div[@class="method-detail anchor-link "]').each do |method_detail|
      method_name = method_detail.xpath('.//span[@class="method-name"]').text
      # puts "Method: #{method_name.inspect}"
      # gets

      method_description = method_detail.xpath('.//dl[@class="rdoc-list note-list"]').text
      # puts "Desc: #{method_description.inspect}"
      # gets

      user_content = "#{module_name}.#{method_name} Usage"
      assistant_content = "`#{module_name}.#{method_name}`: #{method_description}"

      jsonl_hash = {
        messages: [
          { role: 'user', content: user_content },
          { role: 'assistant', content: assistant_content }
        ]
      }
      # puts "JSONL: #{jsonl}"
      # gets

      html_to_jsonl.push("#{jsonl_hash.to_json}\n")
    end
  end

  # Output JSONL data
  File.write(jsonl_results, html_to_jsonl.join)
rescue Interrupt
  puts "\n#{File.basename($PROGRAM_NAME)} => Goodbye."
rescue StandardError => e
  puts 'ERROR: Something Happend'
  raise e
end
